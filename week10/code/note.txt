在main函数中，return == exit。非main函数中，return会毁段栈。



父子进程对文件的操作：
       1.子进程继承父进程中打开的文件。
       前提是父进程中将文件打开得到一个文件描述符，之后再调用fork函数创建子进程。结果得到的内容是结续写，实际上本质原因是父子进程当中fd对应的文件指针是彼此关联的。
       2.父子进程同时打开同一个文件。
       父子进程中写入一个sleep(1)进行休眠，来是的其他进程进行调度，从而保证在一个进程中文件不被关闭，因为当我们在一个进程中打开一个文件之后处理相应的内容之后，我们执行的是关闭这个文件操作，此子进程就得不到这个文件的文件描述符。
       父子进程中分别打开文件之后再写入内容的话是分别写，这里使用的是O_RDWR，两个进程就是完全独立的，文件表也是独立的。
       如果使用O_APPEND的话还是可以实现我们说的接续写。

       如果父进程在使用fork之前做的事情对于子进程影响很大，也就是我们在fork之前程序所对应的内容，我们在具体使用的时候要注意这一点。而在fork之后的IF语句当中对于父进程和子进程的程序内容是没有相互影响的。本质原因是fork内部实际上已经复制父进程的PCB生成一个新的进程，所以fork返回时子进程已经完全与父进程独立，并且两者是独立被系统调度的。子进程的最终目标是要独立的运行另外的程序。


使用fork()函数需要引用 sys/types.h 和 unistd.h头文件，该函数的返回值类型为pid_t，表示一个非负整数。若程序运行在父进程中，函数返回的PID为子进程的进程号；若运行在子进程中，返回的PID为0. 
如若调用fork()函数创建子进程失败，那么就会返回-1，并且提示错误信息。错误信息有以下两种形式： 
EAGAIN：表示fork()函数没有足够的内存用于复制父进程的分页表和进程结构数据。 
ENOMEM：表示fork()函数分配必要的内核数据结构时内存不足。
fork()函数返回值后，开发人员可以根据返回值的不同，对父进程和子进程执行不同的代码，这样就使得fork()函数具有“调用一次，返回两次”的特点。但是，父进程与子进程的返回顺序并不是固定的，由于fork()函数是系统调用函数，因此取决于系统中其他进程的运行情况和内核的调度算法。


vfork()函数与fork()函数相同，都是系统调用函数，两者的区别是在创建子进程时fork()函数会复制所有父进程的资源，包括进程环境、内存资源等，而vfork()函数在创建子进程时不会复制父进程的所有资源，父子进程共享地址空间。这样，在子进程中对虚拟内存空间中变量的修改，实际上是在修改父进程虚拟内存空间中的值。





